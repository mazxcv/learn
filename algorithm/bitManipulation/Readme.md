# Bit Manipulation

В целых числах за знак перед числом отвечает первый бит
Для отрицательного числа все остальные биты написаны таким образом, что при добавлении такого же положительного числа получим ноль
Таким образом для того чтобы поменять знак перед числом, нужно инвертировать все биты кроме последнего

Сдвиг влево приводит к умножению на 2
Сдвиг вправо к целочисленному делению на 2

В случае с отрицательными числами сдввиг работает следующим образом
логический сдвиг вправо повлечет за собой сдвиг и старшего бита, который отвечал за знак
таким образом, например сдвиг вправо -23 (11101001) к 116 (01110100)
Арифметический сдвиг работает иначе: он сохраняет арифметическую связь с новым числом, сдвинутым  вправо
он сдвигает все биты, но заменяет первый бит первым битом
-23 (11101001) к 11-12 (11110100)

### Получение масок
xor ^
0^0 => 0
0^1 => 1
1^0 => 1
1^1 => 0

0 0101100
&
0 0100000
0 0100000

`(x&(1<<i)) != 0` позволит проверить i бит на 0

### Установка бита 
0 0101100
|
0 1000000
0 1101100
`x|(1<<i) != 0` позволит установить i бит на 1

### Очистка бита 
0 0101100
&  |
1 1011111
0 0001100
`x&~(1<<i) ` позволит установить i бит на 0