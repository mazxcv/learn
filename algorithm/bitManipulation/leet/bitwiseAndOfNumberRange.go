package leet

// https://leetcode.com/problems/bitwise-and-of-numbers-range/

// Даны два целых числа left и right, где 0 <= left <= right <= 2^31 - 1.
// Вернуть битовый оператор & для всех чисел в диапазоне [left, right] включительно.

// Идея.
// Похоже, что побитовый оператор & не будет равен 0 тоько в том случе, если
// у чисел left и right есть одинаковый биты общих степенях двойки
// Тоесть:
// Если right более чем в 2 раза болшье left, то общий & будет равен 0, потому что всегда найдется  число , у которых все значащие биты (тоесть все биты на тех же местах, что и у left) равны 0 у right
// Второй случай: right меньее чем в два раза больше left, тогда надо найти, начиная слева от младшего бита, первый бит, у которого значения у left и right различаются,
// вернуть новое число у которых одинаковые биты у left и right с начала одинаковы
// Можно двигать побитово направо числа left и right, пока они не будут равны

func rangeBitwiseAnd(left int, right int) int {
	if (right >> 1) > left {
		return 0
	}

	countBits := 0
	for left != right {
		left >>= 1
		right >>= 1
		countBits++
	}

	return left << countBits
}
