# Каналы 

## Небуферизированный канал 
2 типа действующих лица:
 - `producer`
 - `consumer`

producer периодически создает `entity` и хочет ее передать
`consumer` занимается тем, что получает сущность 

Идейно вокруг `entity` можно объединить `producer`(несколько) и `consumer`(тоже несколько).
В этой сущности нужно мысленно разделить `producer` и `consumer`, первых в правую комнату, вторых - в левую комнату.
Какой-то `producer` создает `entity` и передает
Когда `consumer` захочет забрать `entity`, он приходит и забирает
При этом `producer`, пока у него не заберут `entity` блокируется, пока у него не заберут `entity` и будет ждать до тех пор, пока за `entity` не придут, если другие `producer` хотят передать `entity`, то они выстраиваются в очередь
Если у `consumer` возникает желание забрать `entity`, он приходит и ждет, если другие `consumer` хотят получить `entity`, то они выстраиваются в очередь за `entity`

`producer` и `consumer` может быть неодинаковое количество, 
Вплоть до того, что `consumer` может быть несколько при одном `producer`  и наоборот
Но, никогда не может быть ситуации, что `producer` оказались среди `consumer` 
В таком случае `producer` назначается `consumer` производит `entity` и пытается у себя забрать, но в тоже время другие `consumer` могли захотеть забрать `entity` и попадают в `deadlock`, потому что `producer`, который стал `consumer` уже забрал `entity`

Итого
Канал - это концепция, которая включает в себя:
 - разделение на роли читатели и писатели
 - помещение их в разные стороны 
 - любое количество участников в рамках одной роли 
 - конкурентно-безопасная передача данных от писателя к читателю из рук в руки
 - блокирующее ожидание при отсутствии второй стороны(когда нужно продюсеру пердать данные, он стоит и блокируется, пока не придет читатель, с читателем тоже самое: он блокируется, пока не получит данные)
 - очереди ожидания для читателей и писателей
 - все  читатели и писатели - горутины, которые работают с каналом, то есть читают и пишут

Роли могут быть комбинированными, в некой особой комнате:
 - может получиться, что `consumer` получил `entity` 
 - `consumer` обработал `entity`  
 - `entity`  перешел в состояение `producer` (мысленно перешел через некую перегородку в комнате)
 - `producer` передал новый `entity`
При этом суть канала не меняется, меняется принцип работы комнаты


## Буферизированный канал 
Пример `rate limiter` - ограничение пропускной способности
Концепция - пусть существует комната с неограниченным входом и ограниченным выходом
Пусть приходит `producer` с данными
Через ограниченный выход продюссер с данными выйти не моежт, он должен положить данные в буфер 
`producer` отдает данные в буфер
`producer` может пройти в проход
при этом `producer` не блокируются, пока буфер не полон 
когда буфер заполниться, `producer` начнут блокироваться

Пусть существует служебная комната с `consumer`
`consumer` иногда забирают данные 
буфер становится неполным
и примерно однвременно могут отработать сразу несколько `producer` и заполнить данными буфер
Если буфер полон, то `producer` выстраиваются в очередь

Существуют и другие концепции, например, `worker pool` `semaphore` 

Каналы с буфером и без буфера не взаимозаменяемы! 

## Сравнение 
Канал используется, когда передача данных между горутинами - это конечная цель коммуникации
Канал с буфером используется, когда горутины передают друг другу служебную информацию об определенном поведении, например, с `rate limit` горутины говорят, что переложили токены в буфер, а делать они будут другую работу.

Использование канала с буфером только  для передачи данных, но это оверхэд. Придется более внимательно писать код, учитывать возможные потери данных
Если без буфера не обойтись для потоковой передачи данных, то стоит использовать готовые решения `Apache Kafka`
Там данные можно посмотреть, существуют гарантии доставки

## Итого

В канале происходит монотонная работа по передаче данных 
от одной горутины к другой
конкурентно-безопасно (остальные в очереди)
взаимодействуют много горутин
взаимодействие:
- последовательно
- монотонно
- по одной единице данных за один раз

### Аналогия с трубой неверна
Ниже описаны 5 писателей и 4  читателя
в данном случае обычно успевают читать не более пары читателей, но тем не менее пример указывает на то, что когда появился свободный читатель, тогда он попытался вычитать из канала данные
```golang
const cntWorkers = 5
const cntReaders = 4

func main() {
	ch := make(chan int)

	wg := &sync.WaitGroup{}
	wg.Add(cntWorkers)
	for j := range cntWorkers {
		go func() {
			defer wg.Done()
			for i := range 10 {
				ch <- i + j*100
			}
		}()
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	for i := range cntReaders {
		go func(i int) {
			for v := range ch {
				fmt.Println("value: ", v, " worker", i)
			}
		}(i)
	}
	go func() {
		for v := range ch {
			fmt.Println("value: ", v, " worker1")
		}
	}()

	for v := range ch {
		fmt.Println("value: ", v, " main")
	}

}

```

# Аксиомы каналов

Для небуферизированного канала

1) Чтение:
   1) Из открытого канала 
      - приведет к блокировке до прихода писателя 
```golang
	ch := make(chan int)
	go func() {
		ch <- 1
	}()

	v := <-ch
	fmt.Println(v)
	v = <-ch
	fmt.Println(v)
```
Мы читаем из канала, в котором уже не идет запись
   2) Из закрытого канала
      - вернет zero value 
   3) Из неиницализированного канала
      - приведет к блокировке навсегда
2) Запись: 
   1) В открытый канал
      - приведет к блокировке до прихода читателя 
```golang 
	ch := make(chan int)
	ch <- 1
```
будет ошибка  deadlock
```golang
	ch := make(chan int)
	ch <- 1
	v := <-ch
	fmt.Println(v)
```
И здесь будет ошибка, на строке с записью заблокировались, ведь там блокируемся до до прихода читателя

   2) В закрытый канал
      - panic!
   3) В неиницализированный канал
      - приведет к блокировке навсегда
```golang
      var ch chan int
      ch <- 1
```
Правильный пример - надо использовать горутины
```golang 
	ch := make(chan int)
	go func() {
		ch <- 1
	}()

	v := <-ch
	fmt.Println(v)
```
3) Закрытие:
   1) Открытого канала
      - приведет к закрытию канала 
   2) Закрытого канала
      - panic! 
   3) Неиницализированного канала
      - panic! 

Буферизированный канал:
1) Чтение:
   1) Из открытого заполненного канала 
      - приведет к блокировке до прихода писателя 
   2) Из открытого незаполненного канала 
      - вернет значение 
   3) Из закрытого и непустого
      - вернет значение
2) Запись: 
   1) В открытый заполненный канал
      - приведет к блокировке до прихода читателя 
   2) В открытый незаполненный каналл
      - запишется значение
   3) В закрытый непустой каналл
      - panic!

Канал на чтение
1) Запись:
   - Ошибка компиляции
 2) Закрытие:
   - Ошибка компиляции

Канал на запись
1) Чтение:
   - Ошибка компиляции


# Оператор select 
```golang
ch1 := make(chan int)
	ch2 := make(chan int)

	go func() {
		ch1 <- 1
	}()

	timer := time.NewTimer(time.Millisecond * 1)

	ctx, cancel := context.WithTimeout(context.Background(), time.Microsecond*1)
	defer cancel()

	ch3 := make(chan int)

	go func() {
		time.Sleep(time.Millisecond * 500)
		close(ch3)
	}()

	select {
	case v := <-ch1:
		fmt.Println(v, " from ch1")
	case v := <-ch2:
		fmt.Println(v, " from ch2")
	default:
		fmt.Println("exited by default")
		// Ниже 4 канала работают по принципу закрытия канала
	case <-time.After(time.Second * 1):
		fmt.Println("exited by after 1 second")
	case <-timer.C:
		fmt.Println("exited by timer")
	case <-ctx.Done():
		fmt.Println("exited by context")
	case <-ch3:
		fmt.Println("exited by ch3")
	}
```

Проброс контекста 

```golang 

ctx, cancel := context.WithTimeout(context.Background(), time.Microsecond*1)
	defer cancel()

	ch := make(chan int)

	go func() {
		for i := range 100 {
			select {
			case ch <- i:
			case <-ctx.Done():
				return
			}

		}
		close(ch)
	}()

	for {
		select {
		case v, ok := <-ch:
			if !ok {
				return
			}
			fmt.Println(v)
		case <-ctx.Done():
			return
		}
	}
```

# Микропаттерны

## Generator
есть функция, которая возвращает канал 
внутри создаем канал 
потом в него пишем 
потом возвращаем канал на чтение

```golang 
func writer() <-chan int {
	ch := make(chan int)

	go func() {
		for i := range 1 {
			ch <- i + 1
		}

		close(ch)
	}()

	return ch
}
```
В чем заключается паттерн: между созданием канала и возвратом из функции не должно быть блокирующих операций
То есть вся запись в канал должна находиться в отдельной горутине

Генератор, если писателей -горутин несколько и надо закрывать канал

```golang
func writer() <-chan int {
	ch := make(chan int)

	wg := &sync.WaitGroup{}
	wg.Add(2)
	go func() {
		defer wg.Done()
		for i := range 10 {
			ch <- i + 1
		}
	}()
	go func() {
		defer wg.Done()
		for i := range 10 {
			ch <- i + 100
		}
	}()

	go func() {
		wg.Wait()
		close(ch)
	}()

	return ch
}

func main() {

	ch := writer()

	for v := range ch {
		fmt.Println(v)
	}
}
```

## Pipeline 

```golang
func double(writerCh <-chan int) <-chan int {
	ch := make(chan int)
	go func() {
		for v := range writerCh {
			time.Sleep(time.Millisecond * 500)
			ch <- v * 2
		}
		close(ch)
	}()

	return ch
}
```

## Закрытие канала и остановка функции

```golang
// Написать обертку над функцией, которая спит неопределенно долго
func randomTimeWork() {
	time.Sleep(time.Duration(rand.Intn(100)) * time.Second)
}

func predicatableTimeWork() {

	ch := make(chan struct{})

	go func() {
		randomTimeWork()
		close(ch)
	}()

	select {
	case <-time.After(time.Second * 3):
		fmt.Println("error: time out after 3 seconds")
	case <-ch:
	}
}
```