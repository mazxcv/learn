# TASK

Дан кусок кода

```golang
func main() {
    counter := 20
    for i := 0; i <= counter; i++ {
        go func() {
            println(i * i)
        }()
    }
    time.Sleep(time.Second)
}
```

Очевидно здесь несколько проблем:
1) Наверно хотели получить список квадратов чисел от 0 до 20
    - но будет выведено скорее всего 441 20 раз
2) `time.Sleep(time.Second())` - Плохой способ синхронизации, мы просто ждем 1 секунду в надежде успеть исполнить все горутины
    - скорее всего получится, но GC может припарковаать горутины на неопределенное время

Что нужно сделать:
1) Не использовать захват переменной, потому что горутина захватит себе значение, когда начнет исполнятся, а исполниться она может когда угодно, скорее всего по окончании действия цикла
    - вместо этого наадо пробросить переменную, в этом случае сначала переменная вычисляется и создается горутина с нужной переменной
2) Исолпьзовать waitGroup

```golang
func main() {
    wg := &sync.WaitGroup{}
    counter := 20
    wg.Add(counter)
    for i := 0; i <= counter; i++ {
        go func(i int) {
            defer wg.Done()
            println(i * i)
        }(i)
    }

    wg.Wait()
}
```

```golang
func main() {
    wg := &sync.WaitGroup{}
    counter := 20
    wg.Add(counter)
    for i := 0; i <= counter; i++ {
        i := i
        go func() {
            defer wg.Done()
            println(i * i)
        }()
    }

    wg.Wait()
}
```