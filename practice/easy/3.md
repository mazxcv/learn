# TASK

```golang
func main() {
    storage := make(map[int]int, 1000)

    wg := sync.WaitGroup{}
    ops := 1000
    mu := sync.RWMutex{}
    wg.Add(ops)

    for i := 0; i < ops; i++ {
        i := i
        go func(){
            defer wg.Done()

            mu.Lock()
            defer mu.Unlock()
            storage[i] = i
        }()
    }

    wg.Add(ops)
    for i :=  0; i< ops; i++ {
        i :=i
        go func() {
            defer wg.Done()

            _,_ ; storage[i]
        }()
    }

    wg.Wait()
}
```

Здесь ошибки:
1) горутины, которые пишут могут пересекаться с горутинами, которые читают

Решение:
1) На чтение использовать mutex 
   1) Но операция на чтение не должна блокировать операцию записи, поэтому можно использовать RLock()

```golang
func main() {
    storage := make(map[int]int, 1000)

    wg := sync.WaitGroup{}
    ops := 1000
    mu := sync.RWMutex{}
    wg.Add(ops)

    for i := 0; i < ops; i++ {
        i := i
        go func(){
            defer wg.Done()

            mu.Lock()
            defer mu.Unlock()
            storage[i] = i
        }()
    }

    wg.Add(ops)
    for i :=  0; i< ops; i++ {
        i :=i
        go func() {
            defer wg.Done()
            mu.RLock()
            _,_ ; storage[i]
            mu.RUnlock()
        }()
    }

    wg.Wait()
}
```