# Task

```golang
func main() {
    alreadyStored := make(map[int]struct{})
    mu := sync.Mutex{}
    capacity := 1000

    doubles := make([]int, 0, capacity)
    for i :=0; i < capacity; i++ {
        doubles = append(doubles, rand.Intn(10))
    }

    uniqueIds := make(chan int, capacity)
    wg := sync.WaitGroup{}

    wg.Add(capacity)
    for i ;= 0; i < capacity; i++ {
        i := i
        go func() {
            defer wg.Done()
            if _, ok := alreadyStored[doubles[i]]; !ok {
                mu.Lock()
                alreadyStored[doubles[i]] = struct{}
                mu.Unlock()

                uniqueIds <-  doubles[i]
            }
        }()
    }

    wg.Wait()
    for val := range UniqueIds {
        println(val)
    }
    fmt.Println(UniqueIds)
}
```

Проблемы:
1) Здесь есть deadlock, потому что канал не закрыт
2) В `_, ok := alreadyStored[doubles[i]];` есть чтение, но одновременно у нас есть и запись, поэтому будет гонка

Решения:
1) Закрыть канал 
2) использовать mutex для чтения

```golang
func main() {
    alreadyStored := make(map[int]struct{})
    mu := sync.Mutex{}
    capacity := 1000

    doubles := make([]int, 0, capacity)
    for i :=0; i < capacity; i++ {
        doubles = append(doubles, rand.Intn(10))
    }

    uniqueIds := make(chan int, capacity)
    wg := sync.WaitGroup{}

    wg.Add(capacity)
    for i ;= 0; i < capacity; i++ {
        i := i
        go func() {
            defer wg.Done()
            mu.Lock()
            defer mu.Unlock()
            if _, ok := alreadyStored[doubles[i]]; !ok {
                alreadyStored[doubles[i]] = struct{}
                uniqueIds <-  doubles[i]
            }
        }()
    }

    wg.Wait()
    close(uniqueIds)
    for val := range uniqueIds {
        println(val)
    }
    fmt.Println(uniqueIds)
}
```