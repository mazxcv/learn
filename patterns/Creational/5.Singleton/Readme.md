# Одиночка
Singleton
Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

# Проблема
Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности класса.
1. Гарантирует наличие единственного экземпляра класса. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных. Создан объект, а через некоторое время требуется получить старый объект, вместо создания нового. Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса всегда возвращает новый объект.
2. Глобальный доступ к одному объекту.Клиенты могут не подозревать, что работают с одним и тем же объектом. Предоставляет глобальную точку доступа. Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.

Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.

# Решение
Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки. Если есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. При вызове из любой точки кода, он всегда будет отдавать один и тот же объект.

# Структура

Одиночка определяет статический метод getInstance, который возвращает единственный экземпляр своего класса. Конструктор одиночки должен быть скрыт от клиентов. Вызов метода getInstance должен стать единственным способом получить объект этого класса.

# Псевдокод
В этом примере роль Одиночки отыгрывает класс подключения к базе данных.

Этот класс не имеет публичного конструктора, поэтому единственный способ получить его объект — это вызвать метод getInstance. Этот метод сохранит первый созданный объект и будет возвращать его при всех последующих вызовах.

```java
// Класс одиночки определяет статический метод `getInstance`,
// который позволяет клиентам повторно использовать одно и то же
// подключение к базе данных по всей программе.
class Database is
    // Поле для хранения объекта-одиночки должно быть объявлено
    // статичным.
    private static field instance: Database

    // Конструктор одиночки всегда должен оставаться приватным,
    // чтобы клиенты не могли самостоятельно создавать
    // экземпляры этого класса через оператор `new`.
    private constructor Database() is
        // Здесь может жить код инициализации подключения к
        // серверу баз данных.
        // ...

    // Основной статический метод одиночки служит альтернативой
    // конструктору и является точкой доступа к экземпляру этого
    // класса.
    public static method getInstance() is
        if (Database.instance == null) then
            acquireThreadLock() and then
                // На всякий случай ещё раз проверим, не был ли
                // объект создан другим потоком, пока текущий
                // ждал освобождения блокировки.
                if (Database.instance == null) then
                    Database.instance = new Database()
        return Database.instance

    // Наконец, любой класс одиночки должен иметь какую-то
    // полезную функциональность, которую клиенты будут
    // запускать через полученный объект одиночки.
    public method query(sql) is
        // Все запросы к базе данных будут проходить через этот
        // метод. Поэтому имеет смысл поместить сюда какую-то
        // логику кеширования.
        // ...

class Application is
    method main() is
        Database foo = Database.getInstance()
        foo.query("SELECT ...")
        // ...
        Database bar = Database.getInstance()
        bar.query("SELECT ...")
        // Переменная "bar" содержит тот же объект, что и
        // переменная "foo".
```
# Применимость
1. Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы). Одиночка скрывает от клиентов все способы создания нового объекта, кроме специального метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан. 
2. Когда нужно иметь больше контроля над глобальными переменными. В отличие от глобальных переменных, Одиночка гарантирует, что никакой другой код не заменит созданный экземпляр класса.

Тем не менее, в любой момент можно расширить это ограничение и позволить любое количество объектов-одиночек, поменяв код в одном месте (метод getInstance).

# Шаги реализации
1. Добавить в класс приватное статическое поле, которое будет содержать одиночный объект. 
2. Объявить статический создающий метод, который будет использоваться для получения одиночки. 
3. Добавить «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки. 
4. Сделать конструктор класса приватным. 
5. В клиентском коде заменить вызовы конструктора одиночка вызовами его создающего метода.

# Преимущества и недостатки
 - гарантирует наличие единственного экземпляра класса;
 - предоставляет к нему глобальную точку доступа;
 - реализует отложенную инициализацию объекта-одиночки; 
 - нарушает принцип единственной ответственности класса; 
 - маскирует плохой дизайн; 
 - проблемы мультипоточности; 
 - требует постоянного создания Mock-объектов при юнит-тестировании.

# Отношения с другими паттернами
1. Фасад можно сделать Одиночкой, так как обычно нужен только один объект-фасад. 
2. Паттерн Легковес может напоминать Одиночку, если для конкретной задачи у вас получилось свести количество объектов к одному. Но между паттернами есть два кардинальных отличия:
   1. В отличие от Одиночки,можно иметь множество объектов-легковесов. 
   2. Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.
3. Абстрактная фабрика, Строитель и Прототип могут быть реализованы при помощи Одиночки.

# Концептуальный пример
Одиночка — это порождающий паттерн, который гарантирует существование только одного объекта определённого класса, а также позволяет достучаться до этого объекта из любого места программы. Одиночка имеет такие же преимущества и недостатки, что и глобальные переменные. Его невероятно удобно использовать, но он нарушает модульность кода. Не получится просто взять и использовать класс, зависящий от одиночки в другой программе. Для этого придётся эмулировать присутствие одиночки и там. Чаще всего эта проблема проявляется при написании юнит-тестов. 

Обычно, экземпляр одиночки создается во время начальной инициализации структуры. Для этого, определить для структуры метод getInstance. Этот метод будет создавать и возвращать экземпляры одиночки. После создания первого экземпляра, при каждом вызове метода getInstance будет возвращаться именно он. 
А что касательно потоков goroutine? Структура одиночки должна возвращать один и тот же экземпляр в случаях, когда разные потоки пытаются получить доступ к этому экземпляру. По этой причине можно легко ошибиться и неправильно реализовать паттерн Одиночка. 
Некоторые важные детали, о которых нужно помнить:
1. В начале нужна nil-проверка, с ее помощью убедиться что первый экземпляр singleInstance — пустой. Благодаря этому мы можем избежать ресурсоемких операций блокировки при каждом вызове getInstance. Если эта проверка не пройдена, тогда поле singleInstance уже заполнено. 
2. Структура singleInstanceсоздается внутри блокировки. 
3. После блокировки используется еще одна nil-проверка. В случаях, когда первую проверку проходит более одного потока, вторая обеспечивает создание экземпляра одиночки единым потоком. В противном случае, все потоки создавали бы свои экземпляры структуры одиночки.

# Другой пример
Существуют и другие методы создания экземпляра одиночки в Go:

1. Функция init. Можно создавать экземпляр одиночки внутри функции init. Это возможно только в тех случаях, когда ранняя инициализация экземпляра не является проблемой. Функция init вызывается единожды для каждого файла в пакете, поэтому можно быть уверенны в том, что будет создан только один экземпляр.
2. sync.Once. sync.Once выполнит операцию лишь один раз. 